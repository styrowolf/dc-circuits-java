/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package dc.circuits;

import java.lang.Math;

/*
 * TO-DO:
 * Seperate classes into different files.
*/

public class App {

    // testing the code I wrote in main
    // this code is better off as a library though
    // I was tired of calculating these by hand
    // in mastering physics, so why not write some code?
    public static void main(String[] args) {
        ParallelConnection pc = new ParallelConnection(
            new CircuitElement[] {
                new Circuit(new CircuitElement[] {
                    new Resistor(6),
                    new IdealAmmeter(),
                    new Resistor(2),
                }, 0),
                new Circuit(new CircuitElement[] {
                    new Resistor(2),
                    new IdealAmmeter(),
                }, 0),
                new Circuit(new CircuitElement[] {
                    new Resistor(4),
                    new IdealAmmeter(),
                }, 0),
                new Circuit(new CircuitElement[] {
                    new IdealVoltmeter(),
                }, 0),
            }
        );
        Circuit mc = new Circuit(
            new CircuitElement[] {
                pc,
                new Resistor(2),
            }, 22
        );
        mc.calculate();
        System.out.println(mc.voltage());
        System.out.println(mc.current());
        System.out.println(mc.resistance());
        System.out.println(mc.display());
    }
}

// an abstract class to unify the fields 
// and the interfaces of all circuit elements
abstract class CircuitElement {
    double incoming_voltage;
    double resistance;
    double current; 
    boolean is_init;
    
    // these "set" functions are from the Rust prototype I'd written
    // for the sake of being parallel.
    // that implementation is a bit different as there is no such thing
    // as inheritence in Rust, there is only composition.
    // I had used these "set" functions to write to the fields 
    // but in Java, you can just use abstract classes.
    public void set_voltage(double v) {
        this.incoming_voltage = v;
    }

    public void set_current(double i) {
        this.current = i;
    }

    public void set_resistance(double r) {
        this.resistance = r;
    }

    public abstract void calculate();
    public abstract double voltage();
    public abstract double current();
    public abstract double resistance();

    // Is there an interface to display the classes?
    // In Rust, there is std::fmt::Display for this.
    public abstract String name();
    public abstract String display();
}

// a Circuit, which houses an undeterminate number of elements 
// connected in serial in the order of the array.
// the incoming_voltage field is assumed as initialized to the correct value
class Circuit extends CircuitElement {
    CircuitElement[] elements;

    public Circuit(CircuitElement[] e, double v) {
        this.incoming_voltage = v;
        this.is_init = false;
        this.elements = e;
    }

    // always call calculate on main circuit before accessing the fields
    public void calculate() {
        this.calculate_resistance();
        this.set_current(this.voltage() / this.resistance());
        // if this variable is not set here, recursion
        is_init = true;
        for (int i = 0; i < this.elements.length; i++) {
            this.elements[i].set_current(this.current());
            if (this.elements.length == 1) {
                // handling an edge case where an ideal voltmeter 
                // is the only element in the circuit since I = V / (R = inf)
                this.elements[i].set_voltage(this.voltage());
            } else {
                this.elements[i].set_voltage(this.elements[i].resistance() * this.current());
            }
            // call calculate on elements to fill their fields.
            this.elements[i].calculate();
        }
    }

    public double voltage() {
        return this.incoming_voltage;
    }

    public double current() {
        if (!is_init) {
            this.calculate();
        }
        return this.current;
    }
    
    public double resistance() {
        if (!is_init) {
            this.calculate_resistance();
        }
        return this.resistance;
    }

    // adds all the resistances of the circuit elements
    // since they are all connected in serial
    public void calculate_resistance() {
        double r = 0;
        for (int i = 0; i < this.elements.length; i++) {
            r += elements[i].resistance();
        }
        this.set_resistance(r);
    }

    public String name() {
        return "Circuit";
    }

    // this is the basic display function I wrote,
    // as an alternative to Rust's std::fmt::Debug
    public String display() {
        String s = new String();
        s += this.name() + " {\n";
        s += "incoming voltage: " + this.voltage() + "\n";
        s += "current: " + this.current() + "\n";
        s += "resistance: " + this.resistance() + "\n";
        s += "elements:\n";
        for (int i = 0; i < this.elements.length; i++) {
            s += this.elements[i].display();
        }
        s += "}\n";
        return s;
    }
}

// ParallelConnection represents the elements (also other Circuits, 
// which houses many elements connected in serial) connected in parallel.
// the incoming_voltage field is assumed as initialized to the correct value
class ParallelConnection extends CircuitElement {
    CircuitElement[] circuits;

    public ParallelConnection(CircuitElement[] c) {
        this.is_init = false;
        this.circuits = c;
    }

    // R_eq^-1 = (1/R_1 + ... + 1/R_n)
    public double resistance() {
        if (!is_init) {
            double r = 0;
            for (int i = 0; i < this.circuits.length; i++) {
                r += 1 / this.circuits[i].resistance();
            }
            this.resistance = Math.pow(r, -1);
        }
        return this.resistance;
    }

    public double voltage() {
        return this.incoming_voltage;
    }

    public double current() {
        if (!is_init) {
            this.calculate();
        }
        return this.current;
    }

    // voltage is same for each of the elements connected in parallel
    public void calculate() {
        for (int i = 0; i < this.circuits.length; i++) {
            this.circuits[i].set_voltage(this.voltage());
            this.circuits[i].set_current(this.voltage() / this.circuits[i].resistance);
            this.circuits[i].calculate();
        }
        is_init = true;
    }

    public String name() {
        return "ParallelConnection";
    }

    public String display() {
        String s = new String();
        s += this.name() + " {\n";
        s += "incoming voltage: " + this.voltage() + "\n";
        s += "current: " + this.current() + "\n";
        s += "resistance: " + this.resistance() + "\n";
        s += "circuits:\n";
        for (int i = 0; i < this.circuits.length; i++) {
            s += this.circuits[i].display();
        }
        s += "}\n";
        return s;
    }
}

// A basic resistor
class Resistor extends CircuitElement {
    public Resistor(double r) {
        this.resistance = r;
    }

    // there is nothing to calculate for this element
    public void calculate() {}

    public double voltage() {
        return this.incoming_voltage;
    }

    public double current() {
        return this.current;
    }

    public double resistance() {
        return this.resistance;
    }

    public String name() {
        return "Resistor";
    }

    public String display() {
        String s = new String();
        s += this.name() + " {\n";
        s += "incoming voltage: " + this.voltage() + "\n";
        s += "current: " + this.current() + "\n";
        s += "resistance: " + this.resistance() + "\n";
        s += "}\n";
        return s;
    }
}

// An ideal ammeter
class IdealAmmeter extends CircuitElement {
    public IdealAmmeter() {
        this.resistance = 0;
    }

    // there is nothing to calculate for this element
    public void calculate() {}

    public double voltage() {
        return this.incoming_voltage;
    }

    public double current() {
        return this.current;
    }

    public double resistance() {
        return this.resistance;
    }

    public String name() {
        return "IdealAmmeter";
    }

    public String display() {
        String s = new String();
        s += this.name() + " {\n";
        s += "incoming voltage: " + this.voltage() + "\n";
        s += "current: " + this.current() + "\n";
        s += "resistance: " + this.resistance() + "\n";
        s += "}\n";
        return s;
    }
}

// An ideal voltmeter
class IdealVoltmeter extends CircuitElement {
    public IdealVoltmeter() {
        this.resistance = Double.POSITIVE_INFINITY;
    }

    // there is nothing to calculate for this element
    public void calculate() {}

    public double voltage() {
        return this.incoming_voltage;
    }

    public double current() {
        return this.current;
    }

    public double resistance() {
        return this.resistance;
    }

    public String name() {
        return "IdealVoltmeter";
    }

    public String display() {
        String s = new String();
        s += this.name() + " {\n";
        s += "incoming voltage: " + this.voltage() + "\n";
        s += "current: " + this.current() + "\n";
        s += "resistance: " + this.resistance() + "\n";
        s += "}\n";
        return s;
    }
}